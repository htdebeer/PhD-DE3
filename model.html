<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #dddddd; }
td.sourceCode { padding-left: 5px; }
code > span.kw { font-weight: bold; }
code > span.dt { color: #800000; }
code > span.dv { color: #0000ff; }
code > span.bn { color: #0000ff; }
code > span.fl { color: #800080; }
code > span.ch { color: #ff00ff; }
code > span.st { color: #dd0000; }
code > span.co { color: #808080; font-style: italic; }
code > span.al { color: #00ff00; font-weight: bold; }
code > span.fu { color: #000080; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/*</span>
<span class="co"> * Copyright (C) 2013 Huub de Beer</span>
<span class="co"> *</span>
<span class="co"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="co"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="co"> * to deal in the Software without restriction, including without limitation</span>
<span class="co"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="co"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="co"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="co"> *</span>
<span class="co"> * The above copyright notice and this permission notice shall be included in</span>
<span class="co"> * all copies or substantial portions of the Software.</span>
<span class="co"> *</span>
<span class="co"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="co"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="co"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="co"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="co"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="co"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="co"> * DEALINGS IN THE SOFTWARE.</span>
<span class="co"> */</span>

<span class="kw">var</span> model = <span class="kw">function</span>(config) {
    <span class="st">&quot;use strict&quot;</span>;

    <span class="kw">var</span> _model = {},
        _appendix = {};


    <span class="co">// ## Data invariant and initialization</span>
    <span class="co">//</span>
    <span class="co">// This model describes a dynamic phenomenon in terms of changing</span>
    <span class="co">// quantities over time.</span>
    <span class="co">//</span>
    <span class="co">//</span>
    <span class="co">// This description starts at `T_START` milliseconds</span>
    <span class="co">// (ms), defaulting to 0 ms and ends at `T_END` ms. If no end is specified</span>
    <span class="co">// it is assumed that the phenomenon does not end or is still ongoing in</span>
    <span class="co">// the real world (RW). The phenomenon&#39;s change is tracked by &quot;measuring&quot;</span>
    <span class="co">// the changing quantities at consecutive moments in time. These moments</span>
    <span class="co">// are `T_STEP` apart, defaulting to 1 ms, and are tracked by order</span>
    <span class="co">// number.</span>

    <span class="kw">var</span> T_START     = <span class="kw">config.time</span>.<span class="fu">start</span>     || <span class="dv">0</span>,
        T_END       = <span class="kw">config.time</span>.<span class="fu">end</span>       || Infinity,
        T_STEP      = <span class="kw">config.time</span>.<span class="fu">step</span>      || <span class="dv">1</span>;

    <span class="co">// To translate from a moment&#39;s order number to its corresponding time in</span>
    <span class="co">// ms and vice versa, two helper functions are defined, `time_to_moment`</span>
    <span class="co">// and `moment_to_time`, as well as a shorthand name for these two helper</span>
    <span class="co">// functions, respectively, `t2m` and `m2t`.</span>

    <span class="kw">_model</span>.<span class="fu">time</span>_<span class="fu">to</span>_<span class="fu">moment</span> = <span class="kw">function</span>(time) {
        <span class="kw">return</span> <span class="kw">Math</span>.<span class="fu">floor</span>(time / T_STEP); 
    };
    <span class="kw">var</span> t2m = <span class="kw">_model</span>.<span class="fu">time</span>_<span class="fu">to</span>_<span class="fu">moment</span>;

    <span class="kw">_model</span>.<span class="fu">moment</span>_<span class="fu">to</span>_<span class="fu">time</span> = <span class="kw">function</span>(moment) {
        <span class="kw">return</span> moment * T_STEP;
    };
    <span class="kw">var</span> m2t = <span class="kw">_model</span>.<span class="fu">moment</span>_<span class="fu">to</span>_<span class="fu">time</span>;

    <span class="co">// When I use &quot;measured&quot; I mean to denote that the values of the</span>
    <span class="co">// quantities describing the phenomenon have been captured, computed,</span>
    <span class="co">// downloaded, measured, or otherwise obtained. This `model` function is</span>
    <span class="co">// intended to be applicable for describing purely theoretical models of a</span>
    <span class="co">// phenomenon as well as real-time measurements of a phenomenon.</span>
    <span class="co">//</span>
    <span class="co">// &quot;Measuring&quot; a moment is left to the `measure_moment` function. Each</span>
    <span class="co">// model has to (re)implement this function to specify the relationship</span>
    <span class="co">// between the phenomenon&#39;s quantities of interest at each moment during</span>
    <span class="co">// the phenomenon.</span>

    <span class="kw">_model</span>.<span class="fu">measure</span>_<span class="fu">moment</span> = <span class="kw">function</span>(moment) {
        <span class="co">// to be implemented in an object implementing model</span>
    };


    <span class="co">// The model has the following data invariant:</span>
    <span class="co">//</span>
    <span class="co">//   (∀m: 0 ≤ m ≤ |`moments`|: `moment_computed`(`moments`[m]))</span>
    <span class="co">//</span>
    <span class="co">// stating that the phenomenon has been described quantitatively for all</span>
    <span class="co">// moments. These &quot;measurements&quot; are stored in a list of `moments` and can</span>
    <span class="co">// be accessed through a moment&#39;s order number.</span>

    <span class="kw">var</span> moments = [];

    <span class="co">// A moment can only be inspected if it already has been &quot;measured&quot;.</span>
    <span class="co">// Following the data invariant, a moment has been measured when its order</span>
    <span class="co">// number is smaller or equal to the number of measured moments.</span>
    
    <span class="kw">_model</span>.<span class="fu">moment</span>_<span class="fu">measured</span> = <span class="kw">function</span>(moment) {
        <span class="kw">return</span> (moment &lt;= (<span class="kw">moments</span>.<span class="fu">length</span> - <span class="dv">1</span>));
    };

    <span class="co">// Furthermore, the current moment of interest, or `now`, points to an</span>
    <span class="co">// already &quot;measured&quot; moment during the phenomenon&#39;s duration. Hence, the</span>
    <span class="co">// data invariant is extended as follows:</span>
    <span class="co">//</span>
    <span class="co">//   `t2m`(`T_START`) ≤ `now` ≤ `t2m`(`T_END`) → `moment_computed`(`now`)</span>

    <span class="kw">var</span> now;

    <span class="co">// To ensure this data invariant, `now` is set to a moment before the</span>
    <span class="co">// phenomenon started. As a model can be inspected repeatedly, as is one</span>
    <span class="co">// of the reasons to model a phenomenon using a computer, we introduce a</span>
    <span class="co">// `reset` function to resets `now` to a moment before the phenomenon</span>
    <span class="co">// started.</span>

    <span class="kw">_model</span>.<span class="fu">reset</span> = <span class="kw">function</span>() {
        now = t2m(T_START) - <span class="dv">1</span>;
    };
    <span class="kw">_model</span>.<span class="fu">reset</span>();


    <span class="co">// ## Inspecting and running a model</span>

    <span class="co">// Inspection through registerd views</span>

    <span class="kw">var</span> views = [];
    <span class="kw">var</span> update_views = <span class="kw">function</span>() {
        <span class="kw">var</span> update_view = <span class="kw">function</span>(view) {
            <span class="kw">view</span>.<span class="fu">update</span>(_model);
        };
        <span class="kw">views</span>.<span class="fu">forEach</span>(update_view);
    };

    <span class="kw">_model</span>.<span class="fu">register</span> = <span class="kw">function</span>(view) {
        <span class="kw">var</span> view_found = <span class="kw">views</span>.<span class="fu">indexOf</span>(view);
        <span class="kw">if</span> (view_found === -<span class="dv">1</span>) {
            <span class="kw">views</span>.<span class="fu">push</span>(view);
        }
    };

    <span class="kw">_model</span>.<span class="fu">unregister</span> = <span class="kw">function</span>(view) {
        <span class="kw">var</span> view_found = <span class="kw">views</span>.<span class="fu">indexOf</span>(view);
        <span class="kw">if</span> (view_found !== -<span class="dv">1</span>) {
            <span class="kw">views</span>.<span class="fu">slice</span>(view_found, <span class="dv">1</span>);
        }
    };


    <span class="co">// Once a model has been started, the current moment will be measured as</span>
    <span class="co">// well as all moments before since the start. These moments can be</span>
    <span class="co">// inspected.</span>
    <span class="co">//</span>
    <span class="kw">_model</span>.<span class="fu">has</span>_<span class="fu">started</span> = <span class="kw">function</span>() {
        <span class="kw">return</span> now &gt;= <span class="dv">0</span>;
    };

    <span class="co">// The `step` function will advance `now` to the next moment if the end of</span>
    <span class="co">// the phenomenon has not been reached yet. If that moment has not been</span>
    <span class="co">// &quot;measured&quot; earlier, &quot;measure&quot; it now.</span>

    <span class="kw">_model</span>.<span class="fu">step</span> = <span class="kw">function</span>(do_not_update_views) {
        <span class="kw">if</span> (m2t(now) + T_STEP &lt;= T_END) {
            now++;
            <span class="kw">if</span> (!<span class="kw">_model</span>.<span class="fu">moment</span>_<span class="fu">measured</span>(now)) {
                <span class="kw">var</span> moment = <span class="kw">_model</span>.<span class="fu">measure</span>_<span class="fu">moment</span>(now);
                <span class="kw">moment</span>._<span class="fu">time</span>_ = m2t(now);
                <span class="kw">moments</span>.<span class="fu">push</span>(moment);
            }
        }
        <span class="kw">if</span> (!do_not_update_views) {
            update_views();
        }
        <span class="kw">return</span> now;
    };

    <span class="co">// If the phenomenon is a finite process or the &quot;measuring&quot; process cannot</span>
    <span class="co">// go further `T_END` will have a value that is not `Infinity`.</span>

    <span class="kw">_model</span>.<span class="fu">can</span>_<span class="fu">finish</span> = <span class="kw">function</span>() {
        <span class="kw">return</span> <span class="kw">Math</span>.<span class="fu">abs</span>(T_END) !== Infinity;
    };

    <span class="co">// To inspect the whole phenomenon at once or inspect the last moment,</span>
    <span class="co">// `finish`ing the model will ensure that all moments during the</span>
    <span class="co">// phenomenon have been &quot;measured&quot;.</span>

    <span class="kw">_model</span>.<span class="fu">finish</span> = <span class="kw">function</span>() {
        <span class="kw">if</span> (<span class="kw">_model</span>.<span class="fu">can</span>_<span class="fu">finish</span>()) {
            <span class="kw">while</span> ((<span class="kw">moments</span>.<span class="fu">length</span> - <span class="dv">1</span>) &lt; t2m(T_END)) {
                <span class="kw">_model</span>.<span class="fu">step</span>();
            }
        }
        <span class="kw">return</span> now;
    };

    <span class="co">// We call the model finished if the current moment, or `now`, is the</span>
    <span class="co">// phenomenon&#39;s last moment.</span>

    <span class="kw">_model</span>.<span class="fu">is</span>_<span class="fu">finished</span> = <span class="kw">function</span>() {
        <span class="kw">return</span> <span class="kw">_model</span>.<span class="fu">can</span>_<span class="fu">finish</span>() &amp;&amp; m2t(now) &gt;= T_END;
    };

           
    <span class="co">// ## Coordinating quantities</span>
    <span class="co">//</span>
    <span class="co">// All quantities that describe the phenomenon being modeled change in</span>
    <span class="co">// coordination with time&#39;s change. Add the model&#39;s time as a quantity to</span>
    <span class="co">// the list with quantities. To allow people to model time as part of</span>
    <span class="co">// their model, for example to describe the phenomenon accelerated, the</span>
    <span class="co">// internal time is added as quantity `_time_` and, as a result, &quot;_time_&quot;</span>
    <span class="co">// is not allowed as a quantity name.</span>

    <span class="kw">_model</span>.<span class="fu">quantities</span> = <span class="kw">config</span>.<span class="fu">quantities</span> || {};
    <span class="kw">_model.quantities</span>._<span class="fu">time</span>_ = {
        <span class="dt">minimum</span>: T_START,
        <span class="dt">maximum</span>: T_END,
        <span class="dt">value</span>: m2t(now),
        <span class="dt">stepsize</span>: T_STEP,
        <span class="dt">unit</span>: <span class="st">&quot;ms&quot;</span>,
        <span class="dt">label</span>: <span class="st">&quot;internal time&quot;</span>,
        <span class="dt">monotonicity</span>: <span class="kw">true</span>
    };

    <span class="kw">_model</span>.<span class="fu">get</span>_<span class="fu">minimum</span> = <span class="kw">function</span>(quantity) {
        <span class="kw">if</span> (<span class="kw">arguments</span>.<span class="fu">length</span>===<span class="dv">0</span>) {
            <span class="co">// called without any arguments: return all minima</span>
            <span class="kw">var</span> minima = {},
                add_minimum = <span class="kw">function</span>(quantity) {
                    minima[quantity] = <span class="kw">_model</span>.<span class="fu">quantities</span>[quantity].<span class="fu">minimum</span>;
                };

            <span class="kw">Object</span>.<span class="fu">keys</span>(<span class="kw">_model</span>.<span class="fu">quantities</span>).<span class="fu">forEach</span>(add_minimum);
            <span class="kw">return</span> minima;
        } <span class="kw">else</span> {
            <span class="co">// return quantity&#39;s minimum</span>
            <span class="kw">return</span> <span class="kw">_model</span>.<span class="fu">quantities</span>[quantity].<span class="fu">minimum</span>;
        }
    };
                    
    <span class="kw">_model</span>.<span class="fu">get</span>_<span class="fu">maximum</span> = <span class="kw">function</span>(quantity) {
        <span class="kw">if</span> (<span class="kw">arguments</span>.<span class="fu">length</span>===<span class="dv">0</span>) {
            <span class="co">// called without any arguments: return all minima</span>
            <span class="kw">var</span> maxima = {},
                add_maximum = <span class="kw">function</span>(quantity) {
                    maxima[quantity] = <span class="kw">_model</span>.<span class="fu">quantities</span>[quantity].<span class="fu">maximum</span>;
                };

            <span class="kw">Object</span>.<span class="fu">keys</span>(<span class="kw">_model</span>.<span class="fu">quantities</span>).<span class="fu">forEach</span>(add_maximum);
            <span class="kw">return</span> maxima;
        } <span class="kw">else</span> {
            <span class="co">// return quantity&#39;s minimum</span>
            <span class="kw">return</span> <span class="kw">_model</span>.<span class="fu">quantities</span>[quantity].<span class="fu">maximum</span>;
        }
    };


    <span class="kw">_model</span>.<span class="fu">find</span>_<span class="fu">moment</span> = <span class="kw">function</span>(quantity, value, EPSILON) {
        <span class="kw">if</span> (<span class="kw">moments</span>.<span class="fu">length</span> === <span class="dv">0</span>) {
            <span class="co">// no moment are measured yet, so there is nothing to be found</span>

            <span class="kw">return</span> -<span class="dv">1</span>;
        } <span class="kw">else</span> {
            <span class="kw">var</span> val = <span class="kw">_appendix</span>.<span class="fu">quantity</span>_<span class="fu">value</span>(quantity);

            <span class="co">// pre: quantity is monotone</span>
            <span class="co">// determine if it is increasing or decreasing</span>
            <span class="co">// determine type of monotonicity</span>
            <span class="co">//</span>
            <span class="co">// As the first moment has been measured and we do know the</span>
            <span class="co">// minimum of this quantity, type of monotonicity follows.</span>

            <span class="kw">var</span> start = val(<span class="dv">0</span>),
                INCREASING = (start === <span class="kw">_model</span>.<span class="fu">get</span>_<span class="fu">minimum</span>(quantity));

            <span class="co">// Use a stupid linear search to find the moment that approaches the</span>
            <span class="co">// value best</span>


            <span class="kw">var</span> m = <span class="dv">0</span>,
                n = <span class="kw">moments</span>.<span class="fu">length</span> - <span class="dv">1</span>,
                approx = <span class="kw">_appendix</span>.<span class="fu">approximates</span>(EPSILON),
                lowerbound,
                upperbound;

            <span class="kw">if</span> (INCREASING) {
                lowerbound = <span class="kw">function</span>(moment) {
                    <span class="kw">return</span> val(moment) &lt; value;
                };
                upperbound = <span class="kw">function</span>(moment) {
                    <span class="kw">return</span> val(moment) &gt; value;
                };
            } <span class="kw">else</span> {
                lowerbound = <span class="kw">function</span>(moment) {
                    <span class="kw">return</span> val(moment) &gt; value;
                };
                upperbound = <span class="kw">function</span>(moment) {
                    <span class="kw">return</span> val(moment) &lt; value;
                };
            }

            <span class="co">// Increasing &quot;function&quot;, meaning</span>
            <span class="co">//</span>
            <span class="co">//  (∀m: 0 ≤ m &lt; |`moments`|: `val`(m) &lt;= `val`(m+1))</span>
            <span class="co">//</span>
            <span class="co">// Therefore,</span>
            <span class="co">//</span>
            <span class="co">//  (∃m, n: 0 ≤ m &lt; n ≤ |`moments`|: </span>
            <span class="co">//      `val`(m) ≤ value ≤ `val`(n) ⋀</span>
            <span class="co">//      (∀p: m &lt; p &lt; n: `val`(p) = value))</span>
            <span class="co">//</span>
            <span class="co">// `find_moment` finds those moments m and n and returns the</span>
            <span class="co">// one closest to value or, when even close, the last moment</span>
            <span class="co">// decreasing is reverse.</span>
            

            <span class="kw">while</span> (lowerbound(m)) {
                m++;
                <span class="kw">if</span> (m&gt;n) {
                    <span class="co">// </span>
                    <span class="kw">return</span> -<span class="dv">1</span>;
                }
            }
            m--;
            <span class="kw">while</span> (upperbound(n)) {
                n--;
                <span class="kw">if</span> (n&lt;m) {
                    <span class="kw">return</span> -<span class="dv">1</span>;
                }
            }
            n++;

            <span class="kw">return</span> (<span class="kw">Math</span>.<span class="fu">abs</span>(val(n)-value) &lt; <span class="kw">Math</span>.<span class="fu">abs</span>(val(m)-value))?<span class="dt">n</span>:m;
        }
    };


    <span class="kw">_model</span>.<span class="fu">get</span> = <span class="kw">function</span>(quantity) {
        <span class="kw">if</span> (now &lt; <span class="dv">0</span>) {
            <span class="kw">return</span> undefined;
        } <span class="kw">else</span> {
            <span class="kw">return</span> moments[now][quantity];
        }
    };
    
    <span class="kw">_model</span>.<span class="fu">set</span> = <span class="kw">function</span>(quantity, value) {
        <span class="kw">var</span> q = <span class="kw">_model</span>.<span class="fu">quantities</span>[quantity];

        <span class="kw">if</span> (value &lt; <span class="kw">q</span>.<span class="fu">minimum</span>) {
            value = <span class="kw">q</span>.<span class="fu">minimum</span>;
        } <span class="kw">else</span> <span class="kw">if</span> (value &gt; <span class="kw">q</span>.<span class="fu">maximum</span>) {
            value = <span class="kw">q</span>.<span class="fu">maximum</span>;
        }

        <span class="co">// q.minimum ≤ value ≤ q.maximum</span>

        <span class="co">// has value already been &quot;measured&quot;?</span>
        <span class="co">// As some quantities can have the same value more often, there are</span>
        <span class="co">// potentially many moments that fit the bill. There can be an unknown</span>
        <span class="co">// amount of moments that aren&#39;t measured as well.</span>
        <span class="co">//</span>
        <span class="co">// However, some quantities will be strictly increasing or decreasing</span>
        <span class="co">// and no value will appear twice. For example, the internal time will</span>
        <span class="co">// only increase. Those quantities with property `monotonicity`</span>
        <span class="co">// `true`, only one value will be searched for</span>
        
        <span class="kw">var</span> approx = <span class="kw">_appendix</span>.<span class="fu">approximates</span>(),
            moments_with_value = [];
        <span class="kw">if</span> (<span class="kw">q</span>.<span class="fu">monotonicity</span>) {
            <span class="kw">var</span> moment = <span class="kw">_model</span>.<span class="fu">find</span>_<span class="fu">moment</span>(quantity, value);
            <span class="kw">if</span> (moment !== -<span class="dv">1</span>) {
                <span class="kw">moments_with_value</span>.<span class="fu">push</span>(moment);
            }
        } <span class="kw">else</span> {
            <span class="co">// This does not work: no guarantee about approximation. Fix this.</span>
            <span class="kw">var</span> has_value = <span class="kw">function</span>(element, index, array) {
                    <span class="kw">console</span>.<span class="fu">log</span>(<span class="st">&quot;set: &quot;</span>, element[quantity], value, approx(element[quantity], value));
                    <span class="kw">return</span> approx(element[quantity],value);
                };
            moments_with_value = <span class="kw">moments</span>.<span class="fu">filter</span>(has_value);
        }

        <span class="kw">if</span> (<span class="kw">moments_with_value</span>.<span class="fu">length</span> === <span class="dv">0</span>) {
            <span class="co">// not yet &quot;measured&quot;</span>
            <span class="kw">var</span> DO_NOT_UPDATE_VIEWS = <span class="kw">true</span>;
            <span class="kw">_model</span>.<span class="fu">step</span>(DO_NOT_UPDATE_VIEWS);
            <span class="kw">while</span>(!approx(moments[now][quantity], value) &amp;&amp; !<span class="kw">_model</span>.<span class="fu">is</span>_<span class="fu">finished</span>()) {
                <span class="kw">_model</span>.<span class="fu">step</span>(DO_NOT_UPDATE_VIEWS);
            }
        } <span class="kw">else</span> {
            now = moments_with_value[<span class="dv">0</span>];
        }
        update_views();
        <span class="kw">return</span> moments[now];
    };

    <span class="kw">_model</span>.<span class="fu">data</span> = <span class="kw">function</span>() {
        <span class="kw">return</span> moments;
    };

    <span class="kw">_model</span>.<span class="fu">current</span>_<span class="fu">moment</span> = <span class="kw">function</span>() {
        <span class="kw">return</span> moments[now];
    };


    <span class="co">// ## _appendix H: helper functions</span>

    <span class="kw">_appendix</span>.<span class="fu">approximates</span> = <span class="kw">function</span>(epsilon) {
            <span class="kw">var</span> EPSILON = epsilon || <span class="fl">0.001</span>,
                fn = <span class="kw">function</span>(a, b) {
                    <span class="kw">return</span> <span class="kw">Math</span>.<span class="fu">abs</span>(a - b) &lt;= EPSILON;
                };
            <span class="kw">fn</span>.<span class="fu">EPSILON</span> = EPSILON;
            <span class="kw">return</span> fn;
        };
    <span class="kw">_appendix</span>.<span class="fu">quantity</span>_<span class="fu">value</span> = <span class="kw">function</span>(quantity) {
            <span class="kw">return</span> <span class="kw">function</span>(moment) {
                <span class="kw">return</span> moments[moment][quantity];
            };
        };


    <span class="kw">return</span> _model;
};    


<span class="kw">module</span>.<span class="fu">exports</span> = model;</code></pre>
</body>
</html>
